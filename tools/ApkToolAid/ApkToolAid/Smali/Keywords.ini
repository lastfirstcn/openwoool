;ApkTool 助手的smali关键字配置文件
;如果删除配置文件，程序启动后会自动创建

;[关键字]
;Group=<组别>：多层组别用\分隔
;Param=[参数]
;ItemListTitle=[提示Title]：为空则为组别中的第一组
;ItemList=[提示内容]：为空则为关键字+空格+参数
;InsertList=[实际插入内容]：为空则为关键字+空格
;Comments=[注释]

;可使用的宏定义，有以下几种：
;%Return%：回车换行
;%Tab%：Tab转空格

[#]
Group=标识符
Param=[注释文字]
Comments=注释标识符，标明后面的文字为注释

[.class]
Group=标识符
Param=<访问权限> [修饰符] <类名>
Comments=类名标识符
Comments1=%Return%
Comments2=例子：
Comments3=.class public Lcom/xxx/yyy/zzz;

[.super]
Group=标识符
Param=<父类名>
Comments=父类标识符
Comments1=%Return%
Comments2=例子：
Comments3=.super Landroid/app/Activity;

[.source]
Group=标识符
Param=<"文件名">
Comments=Java源文件标识符

[.implements]
Group=标识符
Param=<接口名>
Comments=接口标识符
Comments1=%Return%
Comments2=例子：
Comments3=.implements Landroid/view/View$OnClickListener;

[.annotation]
Group=标识符
Param=[注解属性] <注解类名>
Param1=%Tab%[注解字段 = 值]
Param2=.end annotation
InsertList=.annotation
InsertList1=.end annotation
InsertList2=%Return%
Comments=注解标识符

[.field]
Group=标识符
Param=<访问权限> [修饰符] <字段名>:<字段类型> [= 初始值]
Comments=字段申明标识符
Comments1=%Return%
Comments2=例子：
Comments3=.field public static xxx:I = 0x0

[.end]
Group=标识符
Param=<标识符>
Comments=结束标识符
Comments1=%Return%
Comments2=例子：
Comments3=.end method
Comments4=.end array-data
Comments5=.end annotation
Comments6=.end field

[.method]
Group=标识符
Param=<访问权限> [修饰符] <方法原型>
Param1=.end method
InsertList=.method
InsertList1=.end method
InsertList2=%Return%
Comments=方法标识符
Comments1=%Return%
Comments2=例子：
Comments3=.method public static xxx(I)Z
Comments4=.end method

[<init>]
Group=标识符
InsertList=<init>()V
Comments=类构造方法标识符
Comments1=生成一个实例时的构造方法
Comments2=%Return%
Comments3=例子：
Comments4=.method public constructor <init>()V

[<clinit>]
Group=标识符
InsertList=<clinit>()V
Comments=静态构造方法标识符
Comments1=app运行时的构造方法，仅执行一次
Comments2=%Return%
Comments3=例子：
Comments4=.method static constructor <clinit>()V

[.registers]
Group=标识符
Param=<number>
Comments=使用本地寄存器和参数寄存器的总数量

[.locals]
Group=标识符
Param=<number>
Comments=使用本地寄存器的数量，不包含参数寄存器的数量

[.param]
Group=标识符
Param=<参数寄存器>, <"参数说明">
Param1=[.end param]
Comments=参数标识符
Comments1=%Return%
Comments2=例子：
Comments3=.param p1, "index"

[.prologue]
Group=标识符
InsertList=.prologue
Comments=方法中代码开始标识符

[.line]
Group=标识符
Param=<number>
Comments=行号标识符，标明在源代码中的行号

[.catch]
Group=标识符
Param=<错误信息类> <跳转信息>
InsertList=.catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0
Comments=错误捕捉标识符
Comments1=%Return%
Comments2=例子：
Comments3=%Tab%.catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0
Comments4=%Tab%:try_start_0
Comments5=%Tab%:try_end_0
Comments6=%Tab%:catch_0

[.local]
Group=标识符
Param=<寄存器>, <"变量名称">:<变量类型>
Param1=.end local <寄存器>
InsertList=.local v0, "":
InsertList1=.end local v0
InsertList2=%Return%
Comments=寄存器注释标识符
Comments1=%Return%
Comments2=例子：
Comments3=%Tab%.local v0, "index":I
Comments4=%Tab%.end local v0    # "index":I
Comments5=%Return%
Comments6=%Tab%.local v1, "name":Ljava/lang/String;
Comments7=%Tab%.end local v1    # "name":Ljava/lang/String;

[.array-data]
Group=标识符
Param=<字节数>
Param1=.end array-data
InsertList=.array-data
InsertList1=.end array-data
InsertList2=%Return%
Comments=数组数据标识符
Comments1=%Return%
Comments2=例子：
Comments3=%Tab%fill-array-data v0, :array_0
Comments4=%Tab%:array_0
Comments5=%Tab%.array-data 4
Comments6=%Tab%%Tab%0x7f02004c
Comments7=%Tab%%Tab%0x7f02004d
Comments8=%Tab%%Tab%0x7f020049
Comments9=%Tab%%Tab%0x7f020046
Comments10=%Tab%%Tab%0x7f020163
Comments11=%Tab%.end array-data

[.packed-switch]
Group=标识符
Param=<case常量起始量>
Param1=.end packed-switch
InsertList=.packed-switch
InsertList1=.end packed-switch
InsertList2=%Return%
Comments=packed-switch指令使用的索引表
Comments1=%Return%
Comments2=例子：
Comments3=packed-switch vx, :pswitch_data_0
Comments4=:pswitch_data_0
Comments5=.packed-switch 0x0
Comments6=%Tab%:pswitch_0
Comments7=%Tab%:pswitch_1
Comments8=%Tab%:pswitch_2
Comments9=.end packed-switch

[.sparse-switch]
Group=标识符
ItemList=\style{+B}.sparse-switch\style{-B}
ItemList1=.end sparse-switch
InsertList=.sparse-switch
InsertList1=.end sparse-switch
InsertList2=%Return%
Comments=sparse-switch指令使用的查询表
Comments1=%Return%
Comments2=例子：
Comments3=sparse-switch vx, :sswitch_data_0
Comments4=:sswitch_data_0
Comments5=.sparse-switch
Comments6=%Tab%0x1 -> :sswitch_0
Comments7=%Tab%0x3 -> :sswitch_1
Comments8=%Tab%0x2 -> :sswitch_2
Comments9=.end sparse-switch

[public]
Group=访问权限
Comments=公共的，都可以访问

[private]
Group=访问权限
Comments=私有的，只能类内成员可以访问

[protected]
Group=访问权限
Comments=保护的，只能类内成员和子类可以访问

[final]
Group=修饰符
Comments=最终的
Comments1=修饰变量，则该变量只能赋值一次
Comments2=修饰类，则该类不能被继承

[abstract]
Group=修饰符
Comments=抽象的，不能被实例化

[static]
Group=修饰符
Comments=静态的，不依赖实例化

[native]
Group=修饰符
Comments=外部定义的，也就是调用so文件中的方法

[constructor]
Group=修饰符
Comments=构造方法

[synthetic]
Group=修饰符
Comments=由编译器合成的方法

[B]
Group=数据类型
InsertList=B
Comments=byte类型

[C]
Group=数据类型
InsertList=C
Comments=char类型

[D]
Group=数据类型
InsertList=D
Comments=double类型
Comments1=64位，需要2个寄存器

[F]
Group=数据类型
InsertList=F
Comments=float类型

[I]
Group=数据类型
InsertList=I
Comments=int类型

[S]
Group=数据类型
InsertList=S
Comments=short类型

[V]
Group=数据类型
InsertList=V
Comments=void类型

[J]
Group=数据类型
InsertList=J
Comments=long类型
Comments1=64位，需要2个寄存器

[Z]
Group=数据类型
InsertList=Z
Comments=boolean类型

[[]
Group=数据类型
Param=<数据类型>
InsertList=[
Comments=数组类型
Comments1=%Return%
Comments2=例子：
Comments3=int类型的数组：[I
Comments4=boolean类型的数组：[Z
Comments5=string类型的数组：[Ljava/lang/String;

[null]
Group=数据常量
InsertList=null
Comments=空

[true]
Group=数据常量
InsertList=true
Comments=是、真

[false]
Group=数据常量
InsertList=false
Comments=否、假

[nop]
Group=指令
InsertList=nop
Comments=空指令，无操作

[move]
Group=指令\move
Param=vx, vy
Comments=移动vy的内容到vx。两个寄存器都必须在最初的256寄存器范围以内。

[move/from16]
Group=指令\move
Param=vx, vy
Comments=移动vy的内容到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。

[move-wide/from16]
Group=指令\move
Param=vx, vy
Comments=移动一个long/double值，从vy到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。

[move-object]
Group=指令\move
Param=vx, vy
Comments=移动对象引用，从vy到vx。

[move-object/from16]
Group=指令\move
Param=vx, vy
Comments=移动对象引用，从vy到vx。vy可以处理64K寄存器地址，vx可以处理256寄存器地址。

[move-result]
Group=指令\move
Param=vx
Comments=移动上一次方法调用的返回值到vx。

[move-result-wide]
Group=指令\move
Param=vx
Comments=移动上一次方法调用的long/double型返回值到vx, vx+1。

[move-result-object]
Group=指令\move
Param=vx
Comments=移动上一次方法调用的对象引用返回值到vx。

[move-exception]
Group=指令\move
Param=vx
Comments=当方法调用抛出异常时移动异常对象引用到vx。

[return-void]
Group=指令\return
InsertList=return-void
Comments=返回空值。

[return]
Group=指令\return
Param=vx
Comments=返回在vx寄存器的值。

[return-wide]
Group=指令\return
Param=vx
Comments=返回在vx, vx+1寄存器的double/long值。

[return-object]
Group=指令\return
Param=vx
Comments=返回在vx寄存器的对象引用。

[const/4]
Group=指令\const
Param=vx, lit4
Comments=存入4位常量到vx。

[const/16]
Group=指令\const
Param=vx, lit16
Comments=存入16位常量到vx。

[const]
Group=指令\const
Param=vx, lit32
Comments=存入int型常量到vx。

[const/high16]
Group=指令\const
Param=v0, lit16
Comments=存入16位常量到最高位寄存器，用于初始化float值。

[const-wide/16]
Group=指令\const
Param=vx, lit16
Comments=存入int常量到vx, vx+1寄存器，扩展int型常量为long常量。

[const-wide/32]
Group=指令\const
Param=vx, lit32
Comments=存入32位常量到vx, vx+1寄存器，扩展int型常量到long常量。

[const-wide]
Group=指令\const
Param=vx, lit64
Comments=存入64位常量到vx, vx+1寄存器。

[const-wide/high16]
Group=指令\const
Param=vx, lit16
Comments=存入16位常量到最高16位的vx, vx+1寄存器，用于初始化double值。

[const-string]
Group=指令\const
Param=vx, 字符串ID
Comments=存入字符串常量引用到vx，通过字符串ID或字符串。

[const-class]
Group=指令\const
Param=vx, 类型ID
Comments=存入类对象常量到vx，通过类型ID或类型（如Object.class）。

[monitor-enter]
Group=指令
Param=vx
Comments=获得vx寄存器中的对象引用的监视器。

[monitor-exit]
Group=指令
Comments=释放vx寄存器中的对象引用的监视器。

[check-cast]
Group=指令
Param=vx, 类型ID
Comments=检查vx寄存器中的对象引用是否可以转换成类型ID对应类型的实例。如不可转换，抛出ClassCastException 异常，否则继续执行。

[instance-of]
Group=指令
Param=vx, vy, 类型ID
Comments=检查vy寄存器中的对象引用是否是类型ID对应类型的实例，如果是，vx存入非0值，否则vx存入0。

[array-length]
Group=指令
Param=vx, vy
Comments=计算vy寄存器中数组引用的元素长度并将长度存入vx。

[new-instance]
Group=指令
Param=vx, 类型ID
Comments=根据类型ID或类型新建一个对象实例，并将新建的对象的引用存入vx。

[new-array]
Group=指令
Param=vx, vy, 类型ID
Comments=根据类型ID或类型新建一个数组，vy存入数组的长度，vx存入数组的引用。

[filled-new-array]
Group=指令
Param={参数}, 类型ID
Comments=根据类型ID或类型新建一个数组并通过参数填充。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。
Comments1=%Return%
Comments2=例子：
Comments3=filled-new-array {vx, vy}, [I

[filled-new-array-range]
Group=指令
Param={vx..vy}, 类型ID
Comments=根据类型ID或类型新建一个数组并以寄存器范围为参数填充。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。

[fill-array-data]
Group=指令
Param=vx, 偏移量
Comments=用vx的静态数据填充数组引用。静态数据的位址是当前指令位置加偏移量的和。
Comments1=偏移量是32位的数字，静态数据的存储格式如下：
Comments2=%Tab%0003 // 表类型：静态数组数据
Comments3=%Tab%0400 // 每个元素的字节数（这个例子是4字节的int型）
Comments4=%Tab%0300 0000 // 元素个数
Comments5=%Tab%0100 0000 // 元素 #0：int 1
Comments6=%Tab%0200 0000 // 元素 #1：int 2
Comments7=%Tab%0300 0000 // 元素 #2：int 3

[throw]
Group=指令
Param=vx
Comments=抛出异常对象，异常对象的引用在vx寄存器。

[goto]
Group=指令
Param=目标
Comments=通过短偏移量无条件跳转到目标。
Comments1=%Return%
Comments2=例子：
Comments3=goto :goto_0

[goto/16]
Group=指令
Param=目标
Comments=通过16位偏移量无条件跳转到目标。

[goto/32]
Group=指令
Param=目标
Comments=通过32位偏移量无条件跳转到目标。

[packed-switch]
Group=指令
Param=vx, 索引表偏移量
Comments=实现一个switch 语句，case常量是连续的。这个指令使用索引表，vx是在表中找到具体case的指令偏移量的索引，如果无法在表中找到vx对应的索引将继续执行下一个指令（即default case）。
Comments1=表如下所示：
Comments2=%Tab%0001 // 表类型：packed switch表
Comments3=%Tab%0300 // 元素个数
Comments4=%Tab%0000 0000 // 基础元素
Comments5=%Tab%0500 0000 0: 00000005 // case 0: +00000005
Comments6=%Tab%0700 0000 1: 00000007 // case 1: +00000007
Comments7=%Tab%0900 0000 2: 00000009 // case 2: +00000009
Comments8=%Return%
Comments9=例子：
Comments10=packed-switch vx, :pswitch_data_0
Comments11=:pswitch_data_0
Comments12=.packed-switch 0x0
Comments13=%Tab%:pswitch_0
Comments14=%Tab%:pswitch_1
Comments15=%Tab%:pswitch_2
Comments16=.end packed-switch

[sparse-switch]
Group=指令
Param=vx, 查询表偏移量
Comments=实现一个switch 语句，case常量是非连续的。这个指令使用查询表，用于表示case常量和每个case常量的偏移量。如果vx无法在表中匹配将继续执行下一个指令（即default case）。
Comments1=表如下所示：
Comments2=%Tab%0002 // 表类型：sparse switch表
Comments3=%Tab%0300 // 元素个数
Comments4=%Tab%9cff ffff // 第一个case常量: -100
Comments5=%Tab%fa00 0000 // 第二个case常量: 250
Comments6=%Tab%e803 0000 // 第三个case常量: 1000
Comments7=%Tab%0500 0000 // 第一个case常量的偏移量: +5
Comments8=%Tab%0700 0000 // 第二个case常量的偏移量: +7
Comments9=%Tab%0900 0000 // 第三个case常量的偏移量: +9
Comments10=%Return%
Comments11=例子：
Comments12=sparse-switch vx, :sswitch_data_0
Comments13=:sswitch_data_0
Comments14=.sparse-switch
Comments15=%Tab%0x1 -> :sswitch_0
Comments16=%Tab%0x3 -> :sswitch_1
Comments17=%Tab%0x2 -> :sswitch_2
Comments18=.end sparse-switch

[cmpl-float]
Group=指令\cmp
Param=vx, vy, vz
Comments=比较vy和vz的float值并在vx存入int型返回值（比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。）。

[cmpg-float]
Group=指令\cmp
Param=vx, vy, vz
Comments=比较vy和vz的float值并在vx存入int型返回值（比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。）。

[cmpl-double]
Group=指令\cmp
Param=vx, vy, vz
Comments=比较vy和vz的double值并在vx存入int型返回值（比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。）。

[cmpg-double]
Group=指令\cmp
Param=vx, vy, vz
Comments=比较vy和vz的double值并在vx存入int型返回值（比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。）。

[cmp-long]
Group=指令\cmp
Param=vx, vy, vz
Comments=比较vy和vz的long值并在vx存入int型返回值（比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。）。

[if-eq]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx == vy，跳转到目标。vx和vy是int型值。

[if-ne]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx != vy，跳转到目标。vx和vy是int型值。

[if-lt]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx < vy，跳转到目标。vx和vy是int型值。

[if-ge]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx >= vy，跳转到目标。vx和vy是int型值。

[if-gt]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx > vy，跳转到目标。vx和vy是int型值。

[if-le]
Group=指令\if
Param=vx, vy, 目标
Comments=如果vx <= vy，跳转到目标。vx和vy是int型值。

[if-eqz]
Group=指令\if
Param=vx, 目标
Comments=如果vx == 0，跳转到目标。vx是int型值。

[if-nez]
Group=指令\if
Param=vx, 目标
Comments=如果vx != 0，跳转到目标。

[if-ltz]
Group=指令\if
Param=vx, 目标
Comments=如果vx < 0，跳转到目标。

[if-gez]
Group=指令\if
Param=vx, 目标
Comments=如果vx >= 0，跳转到目标。

[if-gtz]
Group=指令\if
Param=vx, 目标
Comments=如果vx > 0，跳转到目标。

[if-lez]
Group=指令\if
Param=vx, 目标
Comments=如果vx <= 0，跳转到目标。

[aget]
Group=指令\aget
Param=vx, vy, vz
Comments=从int数组获取一个int型值到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。

[aget-wide]
Group=指令\aget
Param=vx, vy, vz
Comments=从long/double数组获取一个long/double值到vx,vx+1，数组的引用位于vy，需获取的元素的索引位于vz。

[aget-object]
Group=指令\aget
Param=vx, vy, vz
Comments=从对象引用数组获取一个对象引用到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。

[aget-boolean]
Group=指令\aget
Param=vx, vy, vz
Comments=从boolean数组获取一个boolean值到vx，数组的引用位于vy，需获取的元素的索引位于vz。

[aget-byte]
Group=指令\aget
Param=vx, vy, vz
Comments=从byte数组获取一个byte值到vx，数组的引用位于vy，需获取的元素的索引位于vz。

[aget-char]
Group=指令\aget
Param=vx, vy, vz
Comments=从char数组获取一个char值到vx，数组的引用位于vy，需获取的元素的索引位于vz。

[aget-short]
Group=指令\aget
Param=vx, vy, vz
Comments=从short数组获取一个short值到vx，数组的引用位于vy，需获取的元素的索引位于vz。

[aput]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的int值作为元素存入int数组，数组的引用位于vy，元素的索引位于vz。

[aput-wide]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx,vx+1的double/long值作为元素存入double/long数组，数组的引用位于vy，元素的索引位于vz。

[aput-object]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的对象引用作为元素存入对象引用数组，数组的引用位于vy，元素的索引位于vz。

[aput-boolean]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的boolean值作为元素存入boolean数组，数组的引用位于vy，元素的索引位于vz。

[aput-byte]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的byte值作为元素存入byte数组，数组的引用位于vy，元素的索引位于vz。

[aput-char]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的char值作为元素存入char数组，数组的引用位于vy，元素的索引位于vz。

[aput-short]
Group=指令\aput
Param=vx, vy, vz
Comments=将vx的short值作为元素存入short数组，数组的引用位于vy，元素的索引位于vz。

[iget]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的int型字段到vx，vy寄存器中是该实例的引用。

[iget-wide]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的double/long型字段到vx,vx+1（Double和long值占用两个寄存器），vy寄存器中是该实例的引用。

[iget-object]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取一个实例的对象引用字段到vx，vy寄存器中是该实例的引用。

[iget-boolean]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的boolean型字段到vx，vy寄存器中是该实例的引用。

[iget-byte]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的byte型字段到vx，vy寄存器中是该实例的引用。

[iget-char]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的char型字段到vx，vy寄存器中是该实例的引用。

[iget-short]
Group=指令\iget
Param=vx, vy, 字段ID
Comments=根据字段ID读取实例的short型字段到vx，vy寄存器中是该实例的引用。

[iget-quick]
Group=指令\iget
Param=vx, vy, 偏移量
Comments=获取vy寄存器中实例指向+偏移位置的数据区的值，存入vx（这是一个不安全的指令，仅适用于ODEX文件）。

[iget-wide-quick]
Group=指令\iget
Param=vx, vy, 偏移量
Comments=获取vy寄存器中实例指向+偏移位置的数据区的值，存入vx,vx+1（这是一个不安全的指令，仅适用于ODEX文件）。

[iget-object-quick]
Group=指令\iget
Param=vx, vy, 偏移量
Comments=获取vy寄存器中实例指向+偏移位置的数据区的对象引用，存入vx（这是一个不安全的指令，仅适用于ODEX文件）。

[iput]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的int型字段，vy寄存器中是该实例的引用。

[iput-wide]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx,vx+1寄存器的值存入实例的double/long型字段，vy寄存器中是该实例的引用。

[iput-object]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的对象引用字段，vy寄存器中是该实例的引用。

[iput-boolean]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的boolean型字段，vy寄存器中是该实例的引用。

[iput-byte]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的byte型字段，vy寄存器中是该实例的引用。

[iput-char]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的char型字段，vy寄存器中是该实例的引用。

[iput-short]
Group=指令\iput
Param=vx, vy, 字段ID
Comments=根据字段ID将vx寄存器的值存入实例的short型字段，vy寄存器中是该实例的引用。

[iput-quick]
Group=指令\iput
Param=vx, vy, 偏移量
Comments=将vx寄存器中的值存入vy寄存器中的实例指向+偏移位置的数据区（这是一个不安全的指令，仅适用于ODEX文件）。

[iput-wide-quick]
Group=指令\iput
Param=vx, vy, 偏移量
Comments=将vx,vx+1寄存器中的值存入vy寄存器中的实例指向+偏移位置的数据区（这是一个不安全的指令，仅适用于ODEX文件）。

[iput-object-quick]
Group=指令\iput
Param=vx, vy, 偏移量
Comments=将vx寄存器中的对象引用存入vy寄存器中的实例指向+偏移位置的数据区（这是一个不安全的指令，仅适用于ODEX文件）。

[sget]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态int型字段到vx。

[sget-wide]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态double/long型字段到vx,vx+1。

[sget-object]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态对象引用字段到vx。

[sget-boolean]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态boolean型字段到vx。

[sget-byte]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态byte型字段到vx。

[sget-char]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态char型字段到vx。

[sget-short]
Group=指令\sget
Param=vx, 字段ID
Comments=根据字段ID读取静态short型字段到vx。

[sput]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的值赋值到int型静态字段。

[sput-wide]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx,vx+1寄存器中的值赋值到double/long型静态字段。

[sput-object]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的对象引用赋值到对象引用静态字段。

[sput-boolean]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的值赋值到boolean型静态字段。

[sput-byte]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的值赋值到byte型静态字段。

[sput-char]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的值赋值到char型静态字段。

[sput-short]
Group=指令\sput
Param=vx, 字段ID
Comments=根据字段ID将vx寄存器中的值赋值到short型静态字段。

[invoke-virtual]
Group=指令\invoke
Param={参数}, 方法名
Comments=调用带参数的虚拟方法。

[invoke-super]
Group=指令\invoke
Param={参数}, 方法名
Comments=调用带参数的直接父类的虚拟方法。

[invoke-direct]
Group=指令\invoke
Param={参数}, 方法名
Comments=不解析直接调用带参数的方法。

[invoke-static]
Group=指令\invoke
Param={参数}, 方法名
Comments=调用带参数的静态方法。

[invoke-interface]
Group=指令\invoke
Param={参数}, 方法名
Comments=调用带参数的接口方法。

[invoke-virtual/range]
Group=指令\invoke
Param={vx..vy}, 方法名
Comments=调用以寄存器范围为参数的虚拟方法。该指令第一个寄存器和寄存器的数量将传递给方法。

[invoke-super/range]
Group=指令\invoke
Param={vx..vy}, 方法名
Comments=调用以寄存器范围为参数的直接父类的虚拟方法。该指令第一个寄存器和寄存器的数量将会传递给方法。

[invoke-direct/range]
Group=指令\invoke
Param={vx..vy}, 方法名
Comments=不解析直接调用以寄存器范围为参数的方法。该指令第一个寄存器和寄存器的数量将会传递给方法。

[invoke-static/range]
Group=指令\invoke
Param={vx..vy}, 方法名
Comments=调用以寄存器范围为参数的静态方法。该指令第一个寄存器和寄存器的数量将会传递给方法。

[invoke-interface-range]
Group=指令\invoke
Param={vx..vy}, 方法名
Comments=调用以寄存器范围为参数的接口方法。该指令第一个寄存器和寄存器的数量将会传递给方法。

[invoke-direct-empty]
Group=指令\invoke
Param={参数}, 方法名
Comments=用于空方法的占位符，如Object.<init>。这相当于正常执行了nop指令（这是一个不安全的指令，仅适用于ODEX文件）。
Comments1=%Return%
Comments2=例子：
Comments3=invoke-direct-empty {v0}, Ljava/lang/Object;.<init>:()V
Comments4=替代空方法java/lang/Object;<init>。

[invoke-virtual-quick]
Group=指令\invoke
Param={参数}, 虚拟表偏移量
Comments=调用虚拟方法，使用目标对象虚拟表（这是一个不安全的指令，仅适用于ODEX文件）。

[invoke-virtual-quick/range]
Group=指令\invoke
Param={参数范围}, 虚拟表偏移量
Comments=调用虚拟方法，使用目标对象虚拟表（这是一个不安全的指令，仅适用于ODEX文件）。

[invoke-super-quick]
Group=指令\invoke
Param={参数}, 虚拟表偏移量
Comments=调用父类虚拟方法，使用目标对象的直接父类的虚拟表（这是一个不安全的指令，仅适用于ODEX文件）。

[invoke-super-quick/range]
Group=指令\invoke
Param={参数范围}, 虚拟表偏移量
Comments=调用父类虚拟方法，使用目标对象的直接父类的虚拟表（这是一个不安全的指令，仅适用于ODEX文件）。

[neg-int]
Group=指令\neg
Param=vx, vy
Comments=计算vx = -vy并将结果存入vx。

[neg-long]
Group=指令\neg
Param=vx, vy
Comments=计算vx,vx+1 = -(vy,vy+1) 并将结果存入vx,vx+1。

[neg-float]
Group=指令\neg
Param=vx, vy
Comments=计算vx = -vy并将结果存入vx。

[neg-double]
Group=指令\neg
Param=vx, vy
Comments=计算vx,vx+1=-(vy,vy+1) 并将结果存入vx,vx+1。

[int-to-long]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为long型值存入vx,vx+1。

[int-to-float]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为float型值存入vx。

[int-to-double]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为double型值存入vx,vx+1。

[long-to-int]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的long型值为int型值存入vx。

[long-to-float]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的long型值为float型值存入vx。

[long-to-double]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的long型值为double型值存入vx,vx+1。

[float-to-int]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的float型值为int型值存入vx。

[float-to-long]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的float型值为long型值存入vx,vx+1。

[float-to-double]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的float型值为double型值存入vx,vx+1。

[double-to-int]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的double型值为int型值存入vx。

[double-to-long]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的double型值为long型值存入vx,vx+1。

[double-to-float]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy,vy+1寄存器中的double型值为float型值存入vx。

[int-to-byte]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为byte型值存入vx。

[int-to-char]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为char型值存入vx。

[int-to-short]
Group=指令\数值类型转换
Param=vx, vy
Comments=转换vy寄存器中的int型值为short型值存入vx。

[add-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy + vz并将结果存入vx。

[sub-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy - vz并将结果存入vx。

[mul-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy * vz并将结果存入vx。

[div-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy / vz并将结果存入vx。

[rem-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy % vz并将结果存入vx。

[and-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy 与 vz并将结果存入vx。

[or-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy 或 vz并将结果存入vx。

[xor-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy 异或 vz并将结果存入vx。

[shl-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=左移vy，vz指定移动的位置，结果存入vx。

[shr-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=右移vy，vz指定移动的位置，结果存入vx。

[ushr-int]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=无符号右移vy，vz指定移动的位置，结果存入vx。

[add-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[sub-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[mul-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[div-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[rem-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[and-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 与 vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[or-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 或 vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[xor-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 异或 vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[shl-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=左移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1（Double和long值占用两个寄存器）。

[shr-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1（Double和long值占用两个寄存器）。

[ushr-long]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=无符号右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1（Double和long值占用两个寄存器）。

[add-float]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy + vz并将结果存入vx。

[sub-float]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy - vz并将结果存入vx。

[mul-float]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy * vz并将结果存入vx。

[div-float]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy / vz并将结果存入vx。

[rem-float]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy % vz并将结果存入vx。

[add-double]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[sub-double]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[mul-double]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[div-double]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[rem-double]
Group=指令\数值类型运算
Param=vx, vy, vz
Comments=计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[add-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx + vy并将结果存入vx。

[sub-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx - vy并将结果存入vx。

[mul-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx * vy并将结果存入vx。

[div-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx / vy并将结果存入vx。

[rem-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx % vy并将结果存入vx。

[and-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx 与 vy并将结果存入vx。

[or-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx 或 vy并将结果存入vx。

[xor-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx 异或 vy并将结果存入vx。

[shl-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=左移vx，vy指定移动的位置，并将结果存入vx。

[shr-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=右移vx，vy指定移动的位置，并将结果存入vx。

[ushr-int/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=无符号右移vx，vy指定移动的位置，并将结果存入vx。

[add-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[sub-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[mul-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[div-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[rem-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[and-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 与 vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[or-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 或 vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[xor-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 异或 vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[shl-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=左移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。

[shr-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。

[ushr-long/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=无符号右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。

[add-float/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx + vy并将结果存入vx。

[sub-float/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx - vy并将结果存入vx。

[mul-float/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx * vy并将结果存入vx。

[div-float/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx / vy并将结果存入vx。

[rem-float/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx % vy并将结果存入vx。

[add-double/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[sub-double/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[mul-double/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[div-double/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[rem-double/2addr]
Group=指令\数值类型运算
Param=vx, vy
Comments=计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1（Double和long值占用两个寄存器）。

[add-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy + lit16并将结果存入vx。

[sub-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy - lit16并将结果存入vx。

[mul-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy * lit16并将结果存入vx。

[div-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy / lit16并将结果存入vx。

[rem-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy % lit16并将结果存入vx。

[and-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy 与 lit16并将结果存入vx。

[or-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy 或 lit16并将结果存入vx。

[xor-int/lit16]
Group=指令\数值类型运算
Param=vx, vy, lit16
Comments=计算vy 异或 lit16并将结果存入vx。

[add-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy + lit8并将结果存入vx。

[sub-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy - lit8并将结果存入vx。

[mul-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy * lit8并将结果存入vx。

[div-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy / lit8并将结果存入vx。

[rem-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy % lit8并将结果存入vx。

[and-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy 与 lit8并将结果存入vx。

[or-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy 或 lit8并将结果存入vx。

[xor-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=计算vy异或lit8并将结果存入vx。

[shl-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=左移vy，lit8指定移动的位置，并将结果存入vx。

[shr-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=右移vy，lit8指定移动的位置，并将结果存入vx。

[ushr-int/lit8]
Group=指令\数值类型运算
Param=vx, vy, lit8
Comments=无符号右移vy，lit8指定移动的位置，并将结果存入vx。

[execute-inline]
Group=指令
Param={参数}, 内联ID
Comments=根据内联ID（这是一个不安全的指令，仅适用于ODEX文件）执行内联方法。
Comments1=%Return%
Comments2=例子：
Comments3=execute-inline {v1, v0}, inline #0003
Comments4=执行内联方法#3，参数v1,v0，其中参数v1为"this"的实例，v0是方法的参数。
